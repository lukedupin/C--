Terminals unused in grammar

    VAR_EX
    ASSIGN_CONST
    ERROR


Grammar

    0 $accept: program $end

    1 program: declist

    2 declist: decl declist
    3        | decl

    4 decl: vardec
    5     | fundec

    6 vardec: VAR IDENT ';'
    7       | type_assign IDENT ';'

    8 fundec: EVENT '(' expression ')' compound
    9       | PRE_EVENT '(' expression ')' compound
   10       | POST_EVENT '(' expression ')' compound
   11       | INIT '(' ')' compound

   12 compound: STARTCURLY locvdecs stmtlst '}'
   13         | STARTCURLY locvdecs '}'
   14         | STARTCURLY stmtlst '}'
   15         | STARTCURLY '}'

   16 locvdecs: vardec locvdecs
   17         | vardec

   18 stmtlst: stmt stmtlst
   19        | stmt

   20 stmt: full
   21     | part

   22 full: IF '(' expression ')' full ELSE full
   23     | WHILE '(' expression ')' full
   24     | noncond

   25 noncond: brkstmt
   26        | retstmt
   27        | compound
   28        | expression ';'
   29        | ';'

   30 part: IF '(' expression ')' stmt
   31     | IF '(' expression ')' full ELSE part
   32     | WHILE '(' expression ')' part

   33 expression: var ASSIGN expression
   34           | var ASSIGN '(' type_assign ')' expression
   35           | simpexp

   36 type_assign: INT
   37            | FLOAT

   38 var: IDENT
   39    | var DOT IDENT

   40 simpexp: simpexp logop relexp
   41        | relexp

   42 relexp: addexp relop addexp
   43       | addexp

   44 relop: LEQ
   45      | LESS
   46      | GREAT
   47      | GEQ
   48      | EQ
   49      | NEQ

   50 addexp: addexp addop term
   51       | term

   52 addop: ADD
   53      | SUBT

   54 logop: OR
   55      | AND

   56 term: term mulop unary
   57     | unary

   58 mulop: MUL
   59      | DIV
   60      | MOD
   61      | NOT

   62 unary: unaryop unary
   63      | fact

   64 unaryop: NOT
   65        | SUBT

   66 fact: '(' expression ')'
   67     | var
   68     | constant

   69 constant: NUMBER

   70 brkstmt: BREAK ';'

   71 retstmt: RETURN ';'


Terminals, with rules where they appear

    $end (0) 0
    '(' (40) 8 9 10 11 22 23 30 31 32 34 66
    ')' (41) 8 9 10 11 22 23 30 31 32 34 66
    ';' (59) 6 7 28 29 70 71
    '}' (125) 12 13 14 15
    error (256)
    IF <tokInfo> (258) 22 30 31
    ELSE <tokInfo> (259) 22 31
    RETURN <tokInfo> (260) 71
    WHILE <tokInfo> (261) 23 32
    BREAK <tokInfo> (262) 70
    STARTCURLY <tokInfo> (263) 12 13 14 15
    INIT <tokInfo> (264) 11
    EVENT <tokInfo> (265) 8
    PRE_EVENT <tokInfo> (266) 9
    POST_EVENT <tokInfo> (267) 10
    IDENT <tokInfo> (268) 6 7 38 39
    NUMBER <tokInfo> (269) 69
    FLOAT <tokInfo> (270) 37
    INT <tokInfo> (271) 36
    VAR <tokInfo> (272) 6
    DOT <tokInfo> (273) 39
    VAR_EX <tokInfo> (274)
    MUL <tokInfo> (275) 58
    DIV <tokInfo> (276) 59
    MOD <tokInfo> (277) 60
    AND <tokInfo> (278) 55
    ADD <tokInfo> (279) 52
    SUBT <tokInfo> (280) 53 65
    OR <tokInfo> (281) 54
    GEQ <tokInfo> (282) 47
    NEQ <tokInfo> (283) 49
    LEQ <tokInfo> (284) 44
    GREAT <tokInfo> (285) 46
    LESS <tokInfo> (286) 45
    EQ <tokInfo> (287) 48
    NOT <tokInfo> (288) 61 64
    ASSIGN <tokInfo> (289) 33 34
    ASSIGN_CONST <tokInfo> (290)
    ERROR <tokInfo> (291)


Nonterminals, with rules where they appear

    $accept (41)
        on left: 0
    program <nodeInfo> (42)
        on left: 1
        on right: 0
    declist <nodeInfo> (43)
        on left: 2 3
        on right: 1 2
    decl <nodeInfo> (44)
        on left: 4 5
        on right: 2 3
    vardec <nodeInfo> (45)
        on left: 6 7
        on right: 4 16 17
    fundec <nodeInfo> (46)
        on left: 8 9 10 11
        on right: 5
    compound <nodeInfo> (47)
        on left: 12 13 14 15
        on right: 8 9 10 11 27
    locvdecs <nodeInfo> (48)
        on left: 16 17
        on right: 12 13 16
    stmtlst <nodeInfo> (49)
        on left: 18 19
        on right: 12 14 18
    stmt <nodeInfo> (50)
        on left: 20 21
        on right: 18 19 30
    full <nodeInfo> (51)
        on left: 22 23 24
        on right: 20 22 23 31
    noncond <nodeInfo> (52)
        on left: 25 26 27 28 29
        on right: 24
    part <nodeInfo> (53)
        on left: 30 31 32
        on right: 21 31 32
    expression <nodeInfo> (54)
        on left: 33 34 35
        on right: 8 9 10 22 23 28 30 31 32 33 34 66
    type_assign <nodeInfo> (55)
        on left: 36 37
        on right: 7 34
    var <nodeInfo> (56)
        on left: 38 39
        on right: 33 34 39 67
    simpexp <nodeInfo> (57)
        on left: 40 41
        on right: 35 40
    relexp <nodeInfo> (58)
        on left: 42 43
        on right: 40 41
    relop <nodeInfo> (59)
        on left: 44 45 46 47 48 49
        on right: 42
    addexp <nodeInfo> (60)
        on left: 50 51
        on right: 42 43 50
    addop <nodeInfo> (61)
        on left: 52 53
        on right: 50
    logop <nodeInfo> (62)
        on left: 54 55
        on right: 40
    term <nodeInfo> (63)
        on left: 56 57
        on right: 50 51 56
    mulop <nodeInfo> (64)
        on left: 58 59 60 61
        on right: 56
    unary <nodeInfo> (65)
        on left: 62 63
        on right: 56 57 62
    unaryop <nodeInfo> (66)
        on left: 64 65
        on right: 62
    fact <nodeInfo> (67)
        on left: 66 67 68
        on right: 63
    constant <nodeInfo> (68)
        on left: 69
        on right: 68
    brkstmt <nodeInfo> (69)
        on left: 70
        on right: 25
    retstmt <nodeInfo> (70)
        on left: 71
        on right: 26


State 0

    0 $accept: . program $end

    INIT        shift, and go to state 1
    EVENT       shift, and go to state 2
    PRE_EVENT   shift, and go to state 3
    POST_EVENT  shift, and go to state 4
    FLOAT       shift, and go to state 5
    INT         shift, and go to state 6
    VAR         shift, and go to state 7

    program      go to state 8
    declist      go to state 9
    decl         go to state 10
    vardec       go to state 11
    fundec       go to state 12
    type_assign  go to state 13


State 1

   11 fundec: INIT . '(' ')' compound

    '('  shift, and go to state 14


State 2

    8 fundec: EVENT . '(' expression ')' compound

    '('  shift, and go to state 15


State 3

    9 fundec: PRE_EVENT . '(' expression ')' compound

    '('  shift, and go to state 16


State 4

   10 fundec: POST_EVENT . '(' expression ')' compound

    '('  shift, and go to state 17


State 5

   37 type_assign: FLOAT .

    $default  reduce using rule 37 (type_assign)


State 6

   36 type_assign: INT .

    $default  reduce using rule 36 (type_assign)


State 7

    6 vardec: VAR . IDENT ';'

    IDENT  shift, and go to state 18


State 8

    0 $accept: program . $end

    $end  shift, and go to state 19


State 9

    1 program: declist .

    $default  reduce using rule 1 (program)


State 10

    2 declist: decl . declist
    3        | decl .

    INIT        shift, and go to state 1
    EVENT       shift, and go to state 2
    PRE_EVENT   shift, and go to state 3
    POST_EVENT  shift, and go to state 4
    FLOAT       shift, and go to state 5
    INT         shift, and go to state 6
    VAR         shift, and go to state 7

    $default  reduce using rule 3 (declist)

    declist      go to state 20
    decl         go to state 10
    vardec       go to state 11
    fundec       go to state 12
    type_assign  go to state 13


State 11

    4 decl: vardec .

    $default  reduce using rule 4 (decl)


State 12

    5 decl: fundec .

    $default  reduce using rule 5 (decl)


State 13

    7 vardec: type_assign . IDENT ';'

    IDENT  shift, and go to state 21


State 14

   11 fundec: INIT '(' . ')' compound

    ')'  shift, and go to state 22


State 15

    8 fundec: EVENT '(' . expression ')' compound

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    expression  go to state 28
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37


State 16

    9 fundec: PRE_EVENT '(' . expression ')' compound

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    expression  go to state 38
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37


State 17

   10 fundec: POST_EVENT '(' . expression ')' compound

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    expression  go to state 39
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37


State 18

    6 vardec: VAR IDENT . ';'

    ';'  shift, and go to state 40


State 19

    0 $accept: program $end .

    $default  accept


State 20

    2 declist: decl declist .

    $default  reduce using rule 2 (declist)


State 21

    7 vardec: type_assign IDENT . ';'

    ';'  shift, and go to state 41


State 22

   11 fundec: INIT '(' ')' . compound

    STARTCURLY  shift, and go to state 42

    compound  go to state 43


State 23

   38 var: IDENT .

    $default  reduce using rule 38 (var)


State 24

   69 constant: NUMBER .

    $default  reduce using rule 69 (constant)


State 25

   65 unaryop: SUBT .

    $default  reduce using rule 65 (unaryop)


State 26

   64 unaryop: NOT .

    $default  reduce using rule 64 (unaryop)


State 27

   66 fact: '(' . expression ')'

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    expression  go to state 44
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37


State 28

    8 fundec: EVENT '(' expression . ')' compound

    ')'  shift, and go to state 45


State 29

   33 expression: var . ASSIGN expression
   34           | var . ASSIGN '(' type_assign ')' expression
   39 var: var . DOT IDENT
   67 fact: var .

    DOT     shift, and go to state 46
    ASSIGN  shift, and go to state 47

    $default  reduce using rule 67 (fact)


State 30

   35 expression: simpexp .
   40 simpexp: simpexp . logop relexp

    AND  shift, and go to state 48
    OR   shift, and go to state 49

    $default  reduce using rule 35 (expression)

    logop  go to state 50


State 31

   41 simpexp: relexp .

    $default  reduce using rule 41 (simpexp)


State 32

   42 relexp: addexp . relop addexp
   43       | addexp .
   50 addexp: addexp . addop term

    ADD    shift, and go to state 51
    SUBT   shift, and go to state 52
    GEQ    shift, and go to state 53
    NEQ    shift, and go to state 54
    LEQ    shift, and go to state 55
    GREAT  shift, and go to state 56
    LESS   shift, and go to state 57
    EQ     shift, and go to state 58

    $default  reduce using rule 43 (relexp)

    relop  go to state 59
    addop  go to state 60


State 33

   51 addexp: term .
   56 term: term . mulop unary

    MUL  shift, and go to state 61
    DIV  shift, and go to state 62
    MOD  shift, and go to state 63
    NOT  shift, and go to state 64

    $default  reduce using rule 51 (addexp)

    mulop  go to state 65


State 34

   57 term: unary .

    $default  reduce using rule 57 (term)


State 35

   62 unary: unaryop . unary

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    var       go to state 66
    unary     go to state 67
    unaryop   go to state 35
    fact      go to state 36
    constant  go to state 37


State 36

   63 unary: fact .

    $default  reduce using rule 63 (unary)


State 37

   68 fact: constant .

    $default  reduce using rule 68 (fact)


State 38

    9 fundec: PRE_EVENT '(' expression . ')' compound

    ')'  shift, and go to state 68


State 39

   10 fundec: POST_EVENT '(' expression . ')' compound

    ')'  shift, and go to state 69


State 40

    6 vardec: VAR IDENT ';' .

    $default  reduce using rule 6 (vardec)


State 41

    7 vardec: type_assign IDENT ';' .

    $default  reduce using rule 7 (vardec)


State 42

   12 compound: STARTCURLY . locvdecs stmtlst '}'
   13         | STARTCURLY . locvdecs '}'
   14         | STARTCURLY . stmtlst '}'
   15         | STARTCURLY . '}'

    IF          shift, and go to state 70
    RETURN      shift, and go to state 71
    WHILE       shift, and go to state 72
    BREAK       shift, and go to state 73
    STARTCURLY  shift, and go to state 42
    IDENT       shift, and go to state 23
    NUMBER      shift, and go to state 24
    FLOAT       shift, and go to state 5
    INT         shift, and go to state 6
    VAR         shift, and go to state 7
    SUBT        shift, and go to state 25
    NOT         shift, and go to state 26
    ';'         shift, and go to state 74
    '('         shift, and go to state 27
    '}'         shift, and go to state 75

    vardec       go to state 76
    compound     go to state 77
    locvdecs     go to state 78
    stmtlst      go to state 79
    stmt         go to state 80
    full         go to state 81
    noncond      go to state 82
    part         go to state 83
    expression   go to state 84
    type_assign  go to state 13
    var          go to state 29
    simpexp      go to state 30
    relexp       go to state 31
    addexp       go to state 32
    term         go to state 33
    unary        go to state 34
    unaryop      go to state 35
    fact         go to state 36
    constant     go to state 37
    brkstmt      go to state 85
    retstmt      go to state 86


State 43

   11 fundec: INIT '(' ')' compound .

    $default  reduce using rule 11 (fundec)


State 44

   66 fact: '(' expression . ')'

    ')'  shift, and go to state 87


State 45

    8 fundec: EVENT '(' expression ')' . compound

    STARTCURLY  shift, and go to state 42

    compound  go to state 88


State 46

   39 var: var DOT . IDENT

    IDENT  shift, and go to state 89


State 47

   33 expression: var ASSIGN . expression
   34           | var ASSIGN . '(' type_assign ')' expression

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 90

    expression  go to state 91
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37


State 48

   55 logop: AND .

    $default  reduce using rule 55 (logop)


State 49

   54 logop: OR .

    $default  reduce using rule 54 (logop)


State 50

   40 simpexp: simpexp logop . relexp

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    var       go to state 66
    relexp    go to state 92
    addexp    go to state 32
    term      go to state 33
    unary     go to state 34
    unaryop   go to state 35
    fact      go to state 36
    constant  go to state 37


State 51

   52 addop: ADD .

    $default  reduce using rule 52 (addop)


State 52

   53 addop: SUBT .

    $default  reduce using rule 53 (addop)


State 53

   47 relop: GEQ .

    $default  reduce using rule 47 (relop)


State 54

   49 relop: NEQ .

    $default  reduce using rule 49 (relop)


State 55

   44 relop: LEQ .

    $default  reduce using rule 44 (relop)


State 56

   46 relop: GREAT .

    $default  reduce using rule 46 (relop)


State 57

   45 relop: LESS .

    $default  reduce using rule 45 (relop)


State 58

   48 relop: EQ .

    $default  reduce using rule 48 (relop)


State 59

   42 relexp: addexp relop . addexp

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    var       go to state 66
    addexp    go to state 93
    term      go to state 33
    unary     go to state 34
    unaryop   go to state 35
    fact      go to state 36
    constant  go to state 37


State 60

   50 addexp: addexp addop . term

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    var       go to state 66
    term      go to state 94
    unary     go to state 34
    unaryop   go to state 35
    fact      go to state 36
    constant  go to state 37


State 61

   58 mulop: MUL .

    $default  reduce using rule 58 (mulop)


State 62

   59 mulop: DIV .

    $default  reduce using rule 59 (mulop)


State 63

   60 mulop: MOD .

    $default  reduce using rule 60 (mulop)


State 64

   61 mulop: NOT .

    $default  reduce using rule 61 (mulop)


State 65

   56 term: term mulop . unary

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    var       go to state 66
    unary     go to state 95
    unaryop   go to state 35
    fact      go to state 36
    constant  go to state 37


State 66

   39 var: var . DOT IDENT
   67 fact: var .

    DOT  shift, and go to state 46

    $default  reduce using rule 67 (fact)


State 67

   62 unary: unaryop unary .

    $default  reduce using rule 62 (unary)


State 68

    9 fundec: PRE_EVENT '(' expression ')' . compound

    STARTCURLY  shift, and go to state 42

    compound  go to state 96


State 69

   10 fundec: POST_EVENT '(' expression ')' . compound

    STARTCURLY  shift, and go to state 42

    compound  go to state 97


State 70

   22 full: IF . '(' expression ')' full ELSE full
   30 part: IF . '(' expression ')' stmt
   31     | IF . '(' expression ')' full ELSE part

    '('  shift, and go to state 98


State 71

   71 retstmt: RETURN . ';'

    ';'  shift, and go to state 99


State 72

   23 full: WHILE . '(' expression ')' full
   32 part: WHILE . '(' expression ')' part

    '('  shift, and go to state 100


State 73

   70 brkstmt: BREAK . ';'

    ';'  shift, and go to state 101


State 74

   29 noncond: ';' .

    $default  reduce using rule 29 (noncond)


State 75

   15 compound: STARTCURLY '}' .

    $default  reduce using rule 15 (compound)


State 76

   16 locvdecs: vardec . locvdecs
   17         | vardec .

    FLOAT  shift, and go to state 5
    INT    shift, and go to state 6
    VAR    shift, and go to state 7

    $default  reduce using rule 17 (locvdecs)

    vardec       go to state 76
    locvdecs     go to state 102
    type_assign  go to state 13


State 77

   27 noncond: compound .

    $default  reduce using rule 27 (noncond)


State 78

   12 compound: STARTCURLY locvdecs . stmtlst '}'
   13         | STARTCURLY locvdecs . '}'

    IF          shift, and go to state 70
    RETURN      shift, and go to state 71
    WHILE       shift, and go to state 72
    BREAK       shift, and go to state 73
    STARTCURLY  shift, and go to state 42
    IDENT       shift, and go to state 23
    NUMBER      shift, and go to state 24
    SUBT        shift, and go to state 25
    NOT         shift, and go to state 26
    ';'         shift, and go to state 74
    '('         shift, and go to state 27
    '}'         shift, and go to state 103

    compound    go to state 77
    stmtlst     go to state 104
    stmt        go to state 80
    full        go to state 81
    noncond     go to state 82
    part        go to state 83
    expression  go to state 84
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37
    brkstmt     go to state 85
    retstmt     go to state 86


State 79

   14 compound: STARTCURLY stmtlst . '}'

    '}'  shift, and go to state 105


State 80

   18 stmtlst: stmt . stmtlst
   19        | stmt .

    IF          shift, and go to state 70
    RETURN      shift, and go to state 71
    WHILE       shift, and go to state 72
    BREAK       shift, and go to state 73
    STARTCURLY  shift, and go to state 42
    IDENT       shift, and go to state 23
    NUMBER      shift, and go to state 24
    SUBT        shift, and go to state 25
    NOT         shift, and go to state 26
    ';'         shift, and go to state 74
    '('         shift, and go to state 27

    $default  reduce using rule 19 (stmtlst)

    compound    go to state 77
    stmtlst     go to state 106
    stmt        go to state 80
    full        go to state 81
    noncond     go to state 82
    part        go to state 83
    expression  go to state 84
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37
    brkstmt     go to state 85
    retstmt     go to state 86


State 81

   20 stmt: full .

    $default  reduce using rule 20 (stmt)


State 82

   24 full: noncond .

    $default  reduce using rule 24 (full)


State 83

   21 stmt: part .

    $default  reduce using rule 21 (stmt)


State 84

   28 noncond: expression . ';'

    ';'  shift, and go to state 107


State 85

   25 noncond: brkstmt .

    $default  reduce using rule 25 (noncond)


State 86

   26 noncond: retstmt .

    $default  reduce using rule 26 (noncond)


State 87

   66 fact: '(' expression ')' .

    $default  reduce using rule 66 (fact)


State 88

    8 fundec: EVENT '(' expression ')' compound .

    $default  reduce using rule 8 (fundec)


State 89

   39 var: var DOT IDENT .

    $default  reduce using rule 39 (var)


State 90

   34 expression: var ASSIGN '(' . type_assign ')' expression
   66 fact: '(' . expression ')'

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    FLOAT   shift, and go to state 5
    INT     shift, and go to state 6
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    expression   go to state 44
    type_assign  go to state 108
    var          go to state 29
    simpexp      go to state 30
    relexp       go to state 31
    addexp       go to state 32
    term         go to state 33
    unary        go to state 34
    unaryop      go to state 35
    fact         go to state 36
    constant     go to state 37


State 91

   33 expression: var ASSIGN expression .

    $default  reduce using rule 33 (expression)


State 92

   40 simpexp: simpexp logop relexp .

    $default  reduce using rule 40 (simpexp)


State 93

   42 relexp: addexp relop addexp .
   50 addexp: addexp . addop term

    ADD   shift, and go to state 51
    SUBT  shift, and go to state 52

    $default  reduce using rule 42 (relexp)

    addop  go to state 60


State 94

   50 addexp: addexp addop term .
   56 term: term . mulop unary

    MUL  shift, and go to state 61
    DIV  shift, and go to state 62
    MOD  shift, and go to state 63
    NOT  shift, and go to state 64

    $default  reduce using rule 50 (addexp)

    mulop  go to state 65


State 95

   56 term: term mulop unary .

    $default  reduce using rule 56 (term)


State 96

    9 fundec: PRE_EVENT '(' expression ')' compound .

    $default  reduce using rule 9 (fundec)


State 97

   10 fundec: POST_EVENT '(' expression ')' compound .

    $default  reduce using rule 10 (fundec)


State 98

   22 full: IF '(' . expression ')' full ELSE full
   30 part: IF '(' . expression ')' stmt
   31     | IF '(' . expression ')' full ELSE part

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    expression  go to state 109
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37


State 99

   71 retstmt: RETURN ';' .

    $default  reduce using rule 71 (retstmt)


State 100

   23 full: WHILE '(' . expression ')' full
   32 part: WHILE '(' . expression ')' part

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    expression  go to state 110
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37


State 101

   70 brkstmt: BREAK ';' .

    $default  reduce using rule 70 (brkstmt)


State 102

   16 locvdecs: vardec locvdecs .

    $default  reduce using rule 16 (locvdecs)


State 103

   13 compound: STARTCURLY locvdecs '}' .

    $default  reduce using rule 13 (compound)


State 104

   12 compound: STARTCURLY locvdecs stmtlst . '}'

    '}'  shift, and go to state 111


State 105

   14 compound: STARTCURLY stmtlst '}' .

    $default  reduce using rule 14 (compound)


State 106

   18 stmtlst: stmt stmtlst .

    $default  reduce using rule 18 (stmtlst)


State 107

   28 noncond: expression ';' .

    $default  reduce using rule 28 (noncond)


State 108

   34 expression: var ASSIGN '(' type_assign . ')' expression

    ')'  shift, and go to state 112


State 109

   22 full: IF '(' expression . ')' full ELSE full
   30 part: IF '(' expression . ')' stmt
   31     | IF '(' expression . ')' full ELSE part

    ')'  shift, and go to state 113


State 110

   23 full: WHILE '(' expression . ')' full
   32 part: WHILE '(' expression . ')' part

    ')'  shift, and go to state 114


State 111

   12 compound: STARTCURLY locvdecs stmtlst '}' .

    $default  reduce using rule 12 (compound)


State 112

   34 expression: var ASSIGN '(' type_assign ')' . expression

    IDENT   shift, and go to state 23
    NUMBER  shift, and go to state 24
    SUBT    shift, and go to state 25
    NOT     shift, and go to state 26
    '('     shift, and go to state 27

    expression  go to state 115
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37


State 113

   22 full: IF '(' expression ')' . full ELSE full
   30 part: IF '(' expression ')' . stmt
   31     | IF '(' expression ')' . full ELSE part

    IF          shift, and go to state 70
    RETURN      shift, and go to state 71
    WHILE       shift, and go to state 72
    BREAK       shift, and go to state 73
    STARTCURLY  shift, and go to state 42
    IDENT       shift, and go to state 23
    NUMBER      shift, and go to state 24
    SUBT        shift, and go to state 25
    NOT         shift, and go to state 26
    ';'         shift, and go to state 74
    '('         shift, and go to state 27

    compound    go to state 77
    stmt        go to state 116
    full        go to state 117
    noncond     go to state 82
    part        go to state 83
    expression  go to state 84
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37
    brkstmt     go to state 85
    retstmt     go to state 86


State 114

   23 full: WHILE '(' expression ')' . full
   32 part: WHILE '(' expression ')' . part

    IF          shift, and go to state 70
    RETURN      shift, and go to state 71
    WHILE       shift, and go to state 72
    BREAK       shift, and go to state 73
    STARTCURLY  shift, and go to state 42
    IDENT       shift, and go to state 23
    NUMBER      shift, and go to state 24
    SUBT        shift, and go to state 25
    NOT         shift, and go to state 26
    ';'         shift, and go to state 74
    '('         shift, and go to state 27

    compound    go to state 77
    full        go to state 118
    noncond     go to state 82
    part        go to state 119
    expression  go to state 84
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37
    brkstmt     go to state 85
    retstmt     go to state 86


State 115

   34 expression: var ASSIGN '(' type_assign ')' expression .

    $default  reduce using rule 34 (expression)


State 116

   30 part: IF '(' expression ')' stmt .

    $default  reduce using rule 30 (part)


State 117

   20 stmt: full .
   22 full: IF '(' expression ')' full . ELSE full
   31 part: IF '(' expression ')' full . ELSE part

    ELSE  shift, and go to state 120

    $default  reduce using rule 20 (stmt)


State 118

   23 full: WHILE '(' expression ')' full .

    $default  reduce using rule 23 (full)


State 119

   32 part: WHILE '(' expression ')' part .

    $default  reduce using rule 32 (part)


State 120

   22 full: IF '(' expression ')' full ELSE . full
   31 part: IF '(' expression ')' full ELSE . part

    IF          shift, and go to state 70
    RETURN      shift, and go to state 71
    WHILE       shift, and go to state 72
    BREAK       shift, and go to state 73
    STARTCURLY  shift, and go to state 42
    IDENT       shift, and go to state 23
    NUMBER      shift, and go to state 24
    SUBT        shift, and go to state 25
    NOT         shift, and go to state 26
    ';'         shift, and go to state 74
    '('         shift, and go to state 27

    compound    go to state 77
    full        go to state 121
    noncond     go to state 82
    part        go to state 122
    expression  go to state 84
    var         go to state 29
    simpexp     go to state 30
    relexp      go to state 31
    addexp      go to state 32
    term        go to state 33
    unary       go to state 34
    unaryop     go to state 35
    fact        go to state 36
    constant    go to state 37
    brkstmt     go to state 85
    retstmt     go to state 86


State 121

   22 full: IF '(' expression ')' full ELSE full .

    $default  reduce using rule 22 (full)


State 122

   31 part: IF '(' expression ')' full ELSE part .

    $default  reduce using rule 31 (part)
