Terminals unused in grammar

    CLASS
    CONTINUE
    FALSE
    TRUE
    I16
    I64
    I128
    ERROR


State 23 conflicts: 1 shift/reduce
State 24 conflicts: 1 shift/reduce
State 62 conflicts: 1 shift/reduce
State 63 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: declist

    2 declist: decl declist
    3        | decl

    4 decl: vardec
    5     | fundec

    6 vardec: VAR IDENT ASSIGN expression

    7 fundec: FN IDENT '(' ')' compound

    8 compound: LEFT_CURLY locvdecs stmtlst RIGHT_CURLY
    9         | LEFT_CURLY locvdecs RIGHT_CURLY
   10         | LEFT_CURLY stmtlst RIGHT_CURLY
   11         | LEFT_CURLY RIGHT_CURLY

   12 locvdecs: vardec locvdecs
   13         | vardec

   14 stmtlst: stmt stmtlst
   15        | stmt

   16 stmt: IF '(' expression ')' stmt ELSE stmt
   17     | WHILE '(' expression ')' stmt
   18     | noncond

   19 noncond: brkstmt
   20        | retstmt
   21        | compound
   22        | expression ';'
   23        | ';'

   24 expression: var ASSIGN expression
   25           | var ASSIGN type_assign '(' expression ')'
   26           | simpexp

   27 type_assign: I8
   28            | I32

   29 var: IDENT
   30    | var DOT IDENT

   31 simpexp: simpexp logop relexp
   32        | relexp

   33 relexp: addexp relop addexp
   34       | addexp

   35 relop: LEQ
   36      | LT
   37      | GT
   38      | GEQ
   39      | EQ
   40      | NEQ

   41 addexp: addexp addop term
   42       | term

   43 addop: ADD
   44      | SUB

   45 logop: OR
   46      | AND

   47 term: term mulop unary
   48     | unary

   49 mulop: MUL
   50      | DIV
   51      | MOD
   52      | NOT

   53 unary: unaryop unary
   54      | fact

   55 unaryop: NOT
   56        | SUB

   57 fact: '(' expression ')'
   58     | var
   59     | constant

   60 constant: NUMBER

   61 brkstmt: BREAK ';'

   62 retstmt: RETURN ';'


Terminals, with rules where they appear

    $end (0) 0
    '(' (40) 7 16 17 25 57
    ')' (41) 7 16 17 25 57
    ';' (59) 22 23 61 62
    error (256)
    LEFT_CURLY <tokInfo> (258) 8 9 10 11
    RIGHT_CURLY <tokInfo> (259) 8 9 10 11
    IF <tokInfo> (260) 16
    ELSE <tokInfo> (261) 16
    VAR <tokInfo> (262) 6
    FN <tokInfo> (263) 7
    CLASS <tokInfo> (264)
    RETURN <tokInfo> (265) 62
    WHILE <tokInfo> (266) 17
    BREAK <tokInfo> (267) 61
    CONTINUE <tokInfo> (268)
    FALSE <tokInfo> (269)
    TRUE <tokInfo> (270)
    MUL <tokInfo> (271) 49
    DIV <tokInfo> (272) 50
    MOD <tokInfo> (273) 51
    ADD <tokInfo> (274) 43
    SUB <tokInfo> (275) 44 56
    AND <tokInfo> (276) 46
    OR <tokInfo> (277) 45
    NEQ <tokInfo> (278) 40
    LEQ <tokInfo> (279) 35
    GEQ <tokInfo> (280) 38
    EQ <tokInfo> (281) 39
    GT <tokInfo> (282) 37
    LT <tokInfo> (283) 36
    NOT <tokInfo> (284) 52 55
    ASSIGN <tokInfo> (285) 6 24 25
    DOT <tokInfo> (286) 30
    I8 <tokInfo> (287) 27
    I16 <tokInfo> (288)
    I32 <tokInfo> (289) 28
    I64 <tokInfo> (290)
    I128 <tokInfo> (291)
    IDENT <tokInfo> (292) 6 7 29 30
    NUMBER <tokInfo> (293) 60
    ERROR <tokInfo> (294)


Nonterminals, with rules where they appear

    $accept (43)
        on left: 0
    program <nodeInfo> (44)
        on left: 1
        on right: 0
    declist <nodeInfo> (45)
        on left: 2 3
        on right: 1 2
    decl <nodeInfo> (46)
        on left: 4 5
        on right: 2 3
    vardec <nodeInfo> (47)
        on left: 6
        on right: 4 12 13
    fundec <nodeInfo> (48)
        on left: 7
        on right: 5
    compound <nodeInfo> (49)
        on left: 8 9 10 11
        on right: 7 21
    locvdecs <nodeInfo> (50)
        on left: 12 13
        on right: 8 9 12
    stmtlst <nodeInfo> (51)
        on left: 14 15
        on right: 8 10 14
    stmt <nodeInfo> (52)
        on left: 16 17 18
        on right: 14 15 16 17
    noncond <nodeInfo> (53)
        on left: 19 20 21 22 23
        on right: 18
    expression <nodeInfo> (54)
        on left: 24 25 26
        on right: 6 16 17 22 24 25 57
    type_assign <nodeInfo> (55)
        on left: 27 28
        on right: 25
    var <nodeInfo> (56)
        on left: 29 30
        on right: 24 25 30 58
    simpexp <nodeInfo> (57)
        on left: 31 32
        on right: 26 31
    relexp <nodeInfo> (58)
        on left: 33 34
        on right: 31 32
    relop <nodeInfo> (59)
        on left: 35 36 37 38 39 40
        on right: 33
    addexp <nodeInfo> (60)
        on left: 41 42
        on right: 33 34 41
    addop <nodeInfo> (61)
        on left: 43 44
        on right: 41
    logop <nodeInfo> (62)
        on left: 45 46
        on right: 31
    term <nodeInfo> (63)
        on left: 47 48
        on right: 41 42 47
    mulop <nodeInfo> (64)
        on left: 49 50 51 52
        on right: 47
    unary <nodeInfo> (65)
        on left: 53 54
        on right: 47 48 53
    unaryop <nodeInfo> (66)
        on left: 55 56
        on right: 53
    fact <nodeInfo> (67)
        on left: 57 58 59
        on right: 54
    constant <nodeInfo> (68)
        on left: 60
        on right: 59
    brkstmt <nodeInfo> (69)
        on left: 61
        on right: 19
    retstmt <nodeInfo> (70)
        on left: 62
        on right: 20


State 0

    0 $accept: . program $end

    VAR  shift, and go to state 1
    FN   shift, and go to state 2

    program  go to state 3
    declist  go to state 4
    decl     go to state 5
    vardec   go to state 6
    fundec   go to state 7


State 1

    6 vardec: VAR . IDENT ASSIGN expression

    IDENT  shift, and go to state 8


State 2

    7 fundec: FN . IDENT '(' ')' compound

    IDENT  shift, and go to state 9


State 3

    0 $accept: program . $end

    $end  shift, and go to state 10


State 4

    1 program: declist .

    $default  reduce using rule 1 (program)


State 5

    2 declist: decl . declist
    3        | decl .

    VAR  shift, and go to state 1
    FN   shift, and go to state 2

    $default  reduce using rule 3 (declist)

    declist  go to state 11
    decl     go to state 5
    vardec   go to state 6
    fundec   go to state 7


State 6

    4 decl: vardec .

    $default  reduce using rule 4 (decl)


State 7

    5 decl: fundec .

    $default  reduce using rule 5 (decl)


State 8

    6 vardec: VAR IDENT . ASSIGN expression

    ASSIGN  shift, and go to state 12


State 9

    7 fundec: FN IDENT . '(' ')' compound

    '('  shift, and go to state 13


State 10

    0 $accept: program $end .

    $default  accept


State 11

    2 declist: decl declist .

    $default  reduce using rule 2 (declist)


State 12

    6 vardec: VAR IDENT ASSIGN . expression

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    expression  go to state 19
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28


State 13

    7 fundec: FN IDENT '(' . ')' compound

    ')'  shift, and go to state 29


State 14

   56 unaryop: SUB .

    $default  reduce using rule 56 (unaryop)


State 15

   55 unaryop: NOT .

    $default  reduce using rule 55 (unaryop)


State 16

   29 var: IDENT .

    $default  reduce using rule 29 (var)


State 17

   60 constant: NUMBER .

    $default  reduce using rule 60 (constant)


State 18

   57 fact: '(' . expression ')'

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    expression  go to state 30
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28


State 19

    6 vardec: VAR IDENT ASSIGN expression .

    $default  reduce using rule 6 (vardec)


State 20

   24 expression: var . ASSIGN expression
   25           | var . ASSIGN type_assign '(' expression ')'
   30 var: var . DOT IDENT
   58 fact: var .

    ASSIGN  shift, and go to state 31
    DOT     shift, and go to state 32

    $default  reduce using rule 58 (fact)


State 21

   26 expression: simpexp .
   31 simpexp: simpexp . logop relexp

    AND  shift, and go to state 33
    OR   shift, and go to state 34

    $default  reduce using rule 26 (expression)

    logop  go to state 35


State 22

   32 simpexp: relexp .

    $default  reduce using rule 32 (simpexp)


State 23

   33 relexp: addexp . relop addexp
   34       | addexp .
   41 addexp: addexp . addop term

    ADD  shift, and go to state 36
    SUB  shift, and go to state 37
    NEQ  shift, and go to state 38
    LEQ  shift, and go to state 39
    GEQ  shift, and go to state 40
    EQ   shift, and go to state 41
    GT   shift, and go to state 42
    LT   shift, and go to state 43

    SUB       [reduce using rule 34 (relexp)]
    $default  reduce using rule 34 (relexp)

    relop  go to state 44
    addop  go to state 45


State 24

   42 addexp: term .
   47 term: term . mulop unary

    MUL  shift, and go to state 46
    DIV  shift, and go to state 47
    MOD  shift, and go to state 48
    NOT  shift, and go to state 49

    NOT       [reduce using rule 42 (addexp)]
    $default  reduce using rule 42 (addexp)

    mulop  go to state 50


State 25

   48 term: unary .

    $default  reduce using rule 48 (term)


State 26

   53 unary: unaryop . unary

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    var       go to state 51
    unary     go to state 52
    unaryop   go to state 26
    fact      go to state 27
    constant  go to state 28


State 27

   54 unary: fact .

    $default  reduce using rule 54 (unary)


State 28

   59 fact: constant .

    $default  reduce using rule 59 (fact)


State 29

    7 fundec: FN IDENT '(' ')' . compound

    LEFT_CURLY  shift, and go to state 53

    compound  go to state 54


State 30

   57 fact: '(' expression . ')'

    ')'  shift, and go to state 55


State 31

   24 expression: var ASSIGN . expression
   25           | var ASSIGN . type_assign '(' expression ')'

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    I8      shift, and go to state 56
    I32     shift, and go to state 57
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    expression   go to state 58
    type_assign  go to state 59
    var          go to state 20
    simpexp      go to state 21
    relexp       go to state 22
    addexp       go to state 23
    term         go to state 24
    unary        go to state 25
    unaryop      go to state 26
    fact         go to state 27
    constant     go to state 28


State 32

   30 var: var DOT . IDENT

    IDENT  shift, and go to state 60


State 33

   46 logop: AND .

    $default  reduce using rule 46 (logop)


State 34

   45 logop: OR .

    $default  reduce using rule 45 (logop)


State 35

   31 simpexp: simpexp logop . relexp

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    var       go to state 51
    relexp    go to state 61
    addexp    go to state 23
    term      go to state 24
    unary     go to state 25
    unaryop   go to state 26
    fact      go to state 27
    constant  go to state 28


State 36

   43 addop: ADD .

    $default  reduce using rule 43 (addop)


State 37

   44 addop: SUB .

    $default  reduce using rule 44 (addop)


State 38

   40 relop: NEQ .

    $default  reduce using rule 40 (relop)


State 39

   35 relop: LEQ .

    $default  reduce using rule 35 (relop)


State 40

   38 relop: GEQ .

    $default  reduce using rule 38 (relop)


State 41

   39 relop: EQ .

    $default  reduce using rule 39 (relop)


State 42

   37 relop: GT .

    $default  reduce using rule 37 (relop)


State 43

   36 relop: LT .

    $default  reduce using rule 36 (relop)


State 44

   33 relexp: addexp relop . addexp

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    var       go to state 51
    addexp    go to state 62
    term      go to state 24
    unary     go to state 25
    unaryop   go to state 26
    fact      go to state 27
    constant  go to state 28


State 45

   41 addexp: addexp addop . term

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    var       go to state 51
    term      go to state 63
    unary     go to state 25
    unaryop   go to state 26
    fact      go to state 27
    constant  go to state 28


State 46

   49 mulop: MUL .

    $default  reduce using rule 49 (mulop)


State 47

   50 mulop: DIV .

    $default  reduce using rule 50 (mulop)


State 48

   51 mulop: MOD .

    $default  reduce using rule 51 (mulop)


State 49

   52 mulop: NOT .

    $default  reduce using rule 52 (mulop)


State 50

   47 term: term mulop . unary

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    var       go to state 51
    unary     go to state 64
    unaryop   go to state 26
    fact      go to state 27
    constant  go to state 28


State 51

   30 var: var . DOT IDENT
   58 fact: var .

    DOT  shift, and go to state 32

    $default  reduce using rule 58 (fact)


State 52

   53 unary: unaryop unary .

    $default  reduce using rule 53 (unary)


State 53

    8 compound: LEFT_CURLY . locvdecs stmtlst RIGHT_CURLY
    9         | LEFT_CURLY . locvdecs RIGHT_CURLY
   10         | LEFT_CURLY . stmtlst RIGHT_CURLY
   11         | LEFT_CURLY . RIGHT_CURLY

    LEFT_CURLY   shift, and go to state 53
    RIGHT_CURLY  shift, and go to state 65
    IF           shift, and go to state 66
    VAR          shift, and go to state 1
    RETURN       shift, and go to state 67
    WHILE        shift, and go to state 68
    BREAK        shift, and go to state 69
    SUB          shift, and go to state 14
    NOT          shift, and go to state 15
    IDENT        shift, and go to state 16
    NUMBER       shift, and go to state 17
    '('          shift, and go to state 18
    ';'          shift, and go to state 70

    vardec      go to state 71
    compound    go to state 72
    locvdecs    go to state 73
    stmtlst     go to state 74
    stmt        go to state 75
    noncond     go to state 76
    expression  go to state 77
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28
    brkstmt     go to state 78
    retstmt     go to state 79


State 54

    7 fundec: FN IDENT '(' ')' compound .

    $default  reduce using rule 7 (fundec)


State 55

   57 fact: '(' expression ')' .

    $default  reduce using rule 57 (fact)


State 56

   27 type_assign: I8 .

    $default  reduce using rule 27 (type_assign)


State 57

   28 type_assign: I32 .

    $default  reduce using rule 28 (type_assign)


State 58

   24 expression: var ASSIGN expression .

    $default  reduce using rule 24 (expression)


State 59

   25 expression: var ASSIGN type_assign . '(' expression ')'

    '('  shift, and go to state 80


State 60

   30 var: var DOT IDENT .

    $default  reduce using rule 30 (var)


State 61

   31 simpexp: simpexp logop relexp .

    $default  reduce using rule 31 (simpexp)


State 62

   33 relexp: addexp relop addexp .
   41 addexp: addexp . addop term

    ADD  shift, and go to state 36
    SUB  shift, and go to state 37

    SUB       [reduce using rule 33 (relexp)]
    $default  reduce using rule 33 (relexp)

    addop  go to state 45


State 63

   41 addexp: addexp addop term .
   47 term: term . mulop unary

    MUL  shift, and go to state 46
    DIV  shift, and go to state 47
    MOD  shift, and go to state 48
    NOT  shift, and go to state 49

    NOT       [reduce using rule 41 (addexp)]
    $default  reduce using rule 41 (addexp)

    mulop  go to state 50


State 64

   47 term: term mulop unary .

    $default  reduce using rule 47 (term)


State 65

   11 compound: LEFT_CURLY RIGHT_CURLY .

    $default  reduce using rule 11 (compound)


State 66

   16 stmt: IF . '(' expression ')' stmt ELSE stmt

    '('  shift, and go to state 81


State 67

   62 retstmt: RETURN . ';'

    ';'  shift, and go to state 82


State 68

   17 stmt: WHILE . '(' expression ')' stmt

    '('  shift, and go to state 83


State 69

   61 brkstmt: BREAK . ';'

    ';'  shift, and go to state 84


State 70

   23 noncond: ';' .

    $default  reduce using rule 23 (noncond)


State 71

   12 locvdecs: vardec . locvdecs
   13         | vardec .

    VAR  shift, and go to state 1

    $default  reduce using rule 13 (locvdecs)

    vardec    go to state 71
    locvdecs  go to state 85


State 72

   21 noncond: compound .

    $default  reduce using rule 21 (noncond)


State 73

    8 compound: LEFT_CURLY locvdecs . stmtlst RIGHT_CURLY
    9         | LEFT_CURLY locvdecs . RIGHT_CURLY

    LEFT_CURLY   shift, and go to state 53
    RIGHT_CURLY  shift, and go to state 86
    IF           shift, and go to state 66
    RETURN       shift, and go to state 67
    WHILE        shift, and go to state 68
    BREAK        shift, and go to state 69
    SUB          shift, and go to state 14
    NOT          shift, and go to state 15
    IDENT        shift, and go to state 16
    NUMBER       shift, and go to state 17
    '('          shift, and go to state 18
    ';'          shift, and go to state 70

    compound    go to state 72
    stmtlst     go to state 87
    stmt        go to state 75
    noncond     go to state 76
    expression  go to state 77
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28
    brkstmt     go to state 78
    retstmt     go to state 79


State 74

   10 compound: LEFT_CURLY stmtlst . RIGHT_CURLY

    RIGHT_CURLY  shift, and go to state 88


State 75

   14 stmtlst: stmt . stmtlst
   15        | stmt .

    LEFT_CURLY  shift, and go to state 53
    IF          shift, and go to state 66
    RETURN      shift, and go to state 67
    WHILE       shift, and go to state 68
    BREAK       shift, and go to state 69
    SUB         shift, and go to state 14
    NOT         shift, and go to state 15
    IDENT       shift, and go to state 16
    NUMBER      shift, and go to state 17
    '('         shift, and go to state 18
    ';'         shift, and go to state 70

    $default  reduce using rule 15 (stmtlst)

    compound    go to state 72
    stmtlst     go to state 89
    stmt        go to state 75
    noncond     go to state 76
    expression  go to state 77
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28
    brkstmt     go to state 78
    retstmt     go to state 79


State 76

   18 stmt: noncond .

    $default  reduce using rule 18 (stmt)


State 77

   22 noncond: expression . ';'

    ';'  shift, and go to state 90


State 78

   19 noncond: brkstmt .

    $default  reduce using rule 19 (noncond)


State 79

   20 noncond: retstmt .

    $default  reduce using rule 20 (noncond)


State 80

   25 expression: var ASSIGN type_assign '(' . expression ')'

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    expression  go to state 91
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28


State 81

   16 stmt: IF '(' . expression ')' stmt ELSE stmt

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    expression  go to state 92
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28


State 82

   62 retstmt: RETURN ';' .

    $default  reduce using rule 62 (retstmt)


State 83

   17 stmt: WHILE '(' . expression ')' stmt

    SUB     shift, and go to state 14
    NOT     shift, and go to state 15
    IDENT   shift, and go to state 16
    NUMBER  shift, and go to state 17
    '('     shift, and go to state 18

    expression  go to state 93
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28


State 84

   61 brkstmt: BREAK ';' .

    $default  reduce using rule 61 (brkstmt)


State 85

   12 locvdecs: vardec locvdecs .

    $default  reduce using rule 12 (locvdecs)


State 86

    9 compound: LEFT_CURLY locvdecs RIGHT_CURLY .

    $default  reduce using rule 9 (compound)


State 87

    8 compound: LEFT_CURLY locvdecs stmtlst . RIGHT_CURLY

    RIGHT_CURLY  shift, and go to state 94


State 88

   10 compound: LEFT_CURLY stmtlst RIGHT_CURLY .

    $default  reduce using rule 10 (compound)


State 89

   14 stmtlst: stmt stmtlst .

    $default  reduce using rule 14 (stmtlst)


State 90

   22 noncond: expression ';' .

    $default  reduce using rule 22 (noncond)


State 91

   25 expression: var ASSIGN type_assign '(' expression . ')'

    ')'  shift, and go to state 95


State 92

   16 stmt: IF '(' expression . ')' stmt ELSE stmt

    ')'  shift, and go to state 96


State 93

   17 stmt: WHILE '(' expression . ')' stmt

    ')'  shift, and go to state 97


State 94

    8 compound: LEFT_CURLY locvdecs stmtlst RIGHT_CURLY .

    $default  reduce using rule 8 (compound)


State 95

   25 expression: var ASSIGN type_assign '(' expression ')' .

    $default  reduce using rule 25 (expression)


State 96

   16 stmt: IF '(' expression ')' . stmt ELSE stmt

    LEFT_CURLY  shift, and go to state 53
    IF          shift, and go to state 66
    RETURN      shift, and go to state 67
    WHILE       shift, and go to state 68
    BREAK       shift, and go to state 69
    SUB         shift, and go to state 14
    NOT         shift, and go to state 15
    IDENT       shift, and go to state 16
    NUMBER      shift, and go to state 17
    '('         shift, and go to state 18
    ';'         shift, and go to state 70

    compound    go to state 72
    stmt        go to state 98
    noncond     go to state 76
    expression  go to state 77
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28
    brkstmt     go to state 78
    retstmt     go to state 79


State 97

   17 stmt: WHILE '(' expression ')' . stmt

    LEFT_CURLY  shift, and go to state 53
    IF          shift, and go to state 66
    RETURN      shift, and go to state 67
    WHILE       shift, and go to state 68
    BREAK       shift, and go to state 69
    SUB         shift, and go to state 14
    NOT         shift, and go to state 15
    IDENT       shift, and go to state 16
    NUMBER      shift, and go to state 17
    '('         shift, and go to state 18
    ';'         shift, and go to state 70

    compound    go to state 72
    stmt        go to state 99
    noncond     go to state 76
    expression  go to state 77
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28
    brkstmt     go to state 78
    retstmt     go to state 79


State 98

   16 stmt: IF '(' expression ')' stmt . ELSE stmt

    ELSE  shift, and go to state 100


State 99

   17 stmt: WHILE '(' expression ')' stmt .

    $default  reduce using rule 17 (stmt)


State 100

   16 stmt: IF '(' expression ')' stmt ELSE . stmt

    LEFT_CURLY  shift, and go to state 53
    IF          shift, and go to state 66
    RETURN      shift, and go to state 67
    WHILE       shift, and go to state 68
    BREAK       shift, and go to state 69
    SUB         shift, and go to state 14
    NOT         shift, and go to state 15
    IDENT       shift, and go to state 16
    NUMBER      shift, and go to state 17
    '('         shift, and go to state 18
    ';'         shift, and go to state 70

    compound    go to state 72
    stmt        go to state 101
    noncond     go to state 76
    expression  go to state 77
    var         go to state 20
    simpexp     go to state 21
    relexp      go to state 22
    addexp      go to state 23
    term        go to state 24
    unary       go to state 25
    unaryop     go to state 26
    fact        go to state 27
    constant    go to state 28
    brkstmt     go to state 78
    retstmt     go to state 79


State 101

   16 stmt: IF '(' expression ')' stmt ELSE stmt .

    $default  reduce using rule 16 (stmt)
